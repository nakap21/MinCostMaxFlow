#include <iostream>
#include <limits>
#include <set>
#include <vector>

class edge{
public:
    int to, time, flow, c, id, rev;
    edge() = default;
    edge(int to, int time, int flow, int c, int id, int rev) : to(to), time(time), flow(flow), c(c), id(id), rev(rev){
    }
};

void addEdge(std::vector<std::vector<edge>>& gr, int from, int to, int time, int ind){
    gr[from].push_back(edge(to, time, 0, 1, ind, gr[to].size()));
    gr[to].push_back(edge(from, -time, 0, 0, ind, gr[from].size() - 1));
    gr[from].push_back(edge(to, -time, 0, 0, ind, gr[to].size()));
    gr[to].push_back(edge(from, time, 0, 1, ind, gr[from].size() - 1));
}


void dfs(std::vector<std::vector<edge>>& gr, int v, std::vector<std::vector<int>>& answer, double& cost, int& n, int& ind, bool& find) {
    if (v == n - 1) {
        find = true;
        return;
    }
    for (int i = 0; i < gr[v].size(); ++i) {
        if (gr[v][i].flow > 0 && gr[gr[v][i].to][gr[v][i].rev].flow < 0) {
            gr[v][i].flow--;
            cost += gr[v][i].time;
            answer[ind].push_back(gr[v][i].id);
            dfs(gr, gr[v][i].to, answer, cost, n, ind, find);
            if (find)
                return;
        }
    }
}


std::vector<int> dijkstra(std::vector<std::vector<edge>>& gr, int v, int& n) {
    static constexpr int INF = std::numeric_limits<int>::max();
    std::vector<int> dist(n, INF);
    std::vector<bool> used(n, false);
    std::vector<int> parent(n, -1);
    dist[v] = 0;
    parent[v] = -1;
    std::set<std::pair<int,int>> heap;
    heap.insert({dist[v], v});
    while (!heap.empty()) {
        int now = heap.begin()->second;
        heap.erase(heap.begin());
        for (int j = 0; j < gr[now].size(); ++j) {
            if (gr[now][j].c - gr[now][j].flow <= 0) {
                continue;
            }
            int to = gr[now][j].to;
            if (dist[now] + gr[now][j].time < dist[to]) {
                heap.erase({dist[to], to});
                dist[to] = dist[now] + gr[now][j].time;
                heap.insert({dist[to], to});
                parent[to] = now;
            }
        }
    }
    return dist;
}

std::vector<std::pair<int, int>> dijkstraFindFlow(std::vector<std::vector<edge>>& gr, std::vector<int>& potential, int v, std::vector<int>& dist, int& n) {
    static constexpr int INF = std::numeric_limits<int>::max();
    std::vector<bool> used(n, false);
    dist.clear();
    dist.assign(n, INF);
    std::vector<int> parent(n, -1);
    std::vector<int> cost(n, -1);
    dist[v] = 0;
    parent[v] = -1;
    std::set<std::pair<int,int>> heap;
    heap.insert({dist[v], v});
    while (!heap.empty()) {
        int now = heap.begin()->second;
        heap.erase(heap.begin());

        for (int j = 0; j < gr[now].size(); ++j) {
            if (gr[now][j].c - gr[now][j].flow <= 0) {
                continue;
            }
            int to = gr[now][j].to;
            int time = gr[now][j].time + potential[now] - potential[to];
            if (dist[now] + time < dist[to]) {
                heap.erase({dist[to], to});
                dist[to] = dist[now] + time;
                parent[to] = now;
                cost[to] = time;
                heap.insert({dist[to], to});
            }
        }
    }
    std::vector<std::pair<int,int>> ans;
    int here = n - 1;
    while (parent[here] != -1) {
        ans.push_back({here, cost[here]});
        here = parent[here];
    }
    ans.push_back({0, -1});
    return ans;
}

void doFlow(std::vector<std::vector<edge>>& gr, std::vector<std::pair<int, int>>& answer, std::vector<int>& potential) {
    for (int i = answer.size() - 1; i > 0; --i) {
        int from = answer[i].first;
        int to = answer[i - 1].first;
        int time = answer[i - 1].second;
        for (int j = 0; j < gr[from].size(); ++j) {
            if (gr[from][j].c - gr[from][j].flow > 0 && gr[from][j].to == to && gr[from][j].time + potential[from] - potential[to] == time) {
                gr[from][j].flow++;
                gr[to][gr[from][j].rev].flow--;
                break;
            }
        }
    }
}

void getData(int& n, int& m, int& k, std::vector<std::vector<edge>>& gr) {
    std::cin >> n >> m >> k;
    gr.resize(n);
    for (int i = 0; i < m; ++i) {
        int from, to, time;
        std::cin >> from >> to >> time;
        from--;
        to--;
        addEdge(gr, from, to, time, i);
    }
}

void print(bool ok, std::vector<std::vector<edge>>& gr, int& n, int& k) {
    if (ok) {
        std::vector<std::vector<int>> answer;
        answer.resize(k);
        double cost = 0;
        int ind = 0;
        for (int i = 0; i < k; ++i) {
            bool find = false;
            dfs(gr, 0, answer, cost, n, ind, find);
            ind++;
        }
        std::cout << cost / (double)k << std::endl;
        for (int i = 0; i < k; ++i) {
            std::cout << answer[i].size() << " ";
            for (int j = 0; j < answer[i].size(); ++j) {
                std::cout << answer[i][j] + 1 << " ";
            }
            std::cout << std::endl;
        }
    } else {
        std::cout << -1;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie();
    std::cout.precision(15);
    int n, m, k;
    std::vector<std::vector<edge>> gr;
    std::vector<int> update;
    std::vector<int> potential;
    getData(n, m, k, gr);
    bool ok = true;
    potential = dijkstra(gr, 0, n);
    int how = 0;
    double allTime = 0;
    while (ok) {
        std::vector<std::pair<int, int>> answer = dijkstraFindFlow(gr, potential, 0, update, n);
        if (answer.size() == 1) {
            ok = false;
            break;
        }
        doFlow(gr, answer, potential);
        how++;
        if (how == k) {
            break;
        }
        for (int i = 0; i < n; ++i) {
            potential[i] = potential[i] + update[i];
        }
    }
    print(ok, gr, n, k);
    return 0;
}
